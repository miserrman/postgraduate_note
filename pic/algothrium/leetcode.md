### 1930. 长度为 3 的不同回文子序列

 显示英文描述

 

[我的提交](https://leetcode-cn.com/contest/weekly-contest-249/problems/unique-length-3-palindromic-subsequences/submissions/)[返回竞赛](https://leetcode-cn.com/contest/weekly-contest-249/)

- **通过的用户数**2316
- **尝试过的用户数**3052
- **用户总通过次数**2348
- **用户总提交次数**6249
- **题目难度****Medium**

给你一个字符串 `s` ，返回 `s` 中 **长度为 3** 的**不同回文子序列** 的个数。

即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。

**回文** 是正着读和反着读一样的字符串。

**子序列** 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。

- 例如，`"ace"` 是 `"***a\***b***c\***d***e\***"` 的一个子序列。

 

**示例 1：**

```
输入：s = "aabca"
输出：3
解释：长度为 3 的 3 个回文子序列分别是：
- "aba" ("aabca" 的子序列)
- "aaa" ("aabca" 的子序列)
- "aca" ("aabca" 的子序列)
```

**示例 2：**

```
输入：s = "adc"
输出：0
解释："adc" 不存在长度为 3 的回文子序列。
```

**示例 3：**

```
输入：s = "bbcbaba"
输出：4
解释：长度为 3 的 4 个回文子序列分别是：
- "bbb" ("bbcbaba" 的子序列)
- "bcb" ("bbcbaba" 的子序列)
- "bab" ("bbcbaba" 的子序列)
- "aba" ("bbcbaba" 的子序列)
```

 

**提示：**

- `3 <= s.length <= 105`
- `s` 仅由小写英文字母组成



#### [1411. 给 N x 3 网格图涂色的方案数](https://leetcode-cn.com/problems/number-of-ways-to-paint-n-3-grid/)

难度困难93

你有一个 `n x 3` 的网格图 `grid` ，你需要用 **红，黄，绿** 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。

给你网格图的行数 `n` 。

请你返回给 `grid` 涂色的方案数。由于答案可能会非常大，请你返回答案对 `10^9 + 7` 取余的结果。

 ![](D:\document\postgraduate\note\pic\e1.png)

**示例 1：**

```
输入：n = 1
输出：12
解释：总共有 12 种可行的方法：
```

**示例 2：**

```
输入：n = 2
输出：54
```

**示例 3：**

```
输入：n = 3
输出：246
```

**示例 4：**

```
输入：n = 7
输出：106494
```

**示例 5：**

```
输入：n = 5000
输出：30228214
```

 

**提示：**

- `n == grid.length`
- `grid[i].length == 3`
- `1 <= n <= 5000`







#### [1888. 使二进制字符串字符交替的最少反转次数](https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)

难度中等38

给你一个二进制字符串 `s` 。你可以按任意顺序执行以下两种操作任意次：

- **类型 1 ：删除** 字符串 `s` 的第一个字符并将它 **添加** 到字符串结尾。
- **类型 2 ：选择** 字符串 `s` 中任意一个字符并将该字符 **反转** ，也就是如果值为 `'0'` ，则反转得到 `'1'` ，反之亦然。

请你返回使 `s` 变成 **交替** 字符串的前提下， **类型 2** 的 **最少** 操作次数 。

我们称一个字符串是 **交替** 的，需要满足任意相邻字符都不同。

- 比方说，字符串 `"010"` 和 `"1010"` 都是交替的，但是字符串 `"0100"` 不是。

 

**示例 1：**

```
输入：s = "111000"
输出：2
解释：执行第一种操作两次，得到 s = "100011" 。
然后对第三个和第六个字符执行第二种操作，得到 s = "101010" 。
```

**示例 2：**

```
输入：s = "010"
输出：0
解释：字符串已经是交替的。
```

**示例 3：**

```
输入：s = "1110"
输出：1
解释：对第二个字符执行第二种操作，得到 s = "1010" 。
```

 

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 要么是 `'0'` ，要么是 `'1'` 。

通过次数2,719

提交次数8,627

解题思路
题意理解（不含证明）
类型 1 和 类型 2 的操作顺序与最终答案无关，只与操作次数有关
按照 01 检测时需要修改的次数，用 len 减去就是按照 10 检测时修改的次数
类型 1 的操作，其实是头尾相接，但是先删除再添加操作开销太大，并且操作很麻烦
将字符串复制一份接在后面，即可使用滑动窗口丝滑拼接
滑窗时减去离开的格子，加上进来的格子，即可避免大量重复计算
答案就是滑窗过程中出现的最小修改次数
图解




优化
感谢评论区，实际上双倍字符串，只需要概念上理解一下，我们可以直接虚拟双倍



答题
C++



```
```

class Solution {
public:
    int minFlips(string s) {
        int len = s.size();
        string target = "01";

        int cnt = 0;
        for (int i = 0; i < len; i++) {
            cnt += (s[i] != target[i % 2]);
        }
    
        //s += s;
        int ans = min({ cnt, len - cnt });
        for (int i = 0; i < len; i++) {
            cnt -= (s[i] != target[i % 2]);
            cnt += (s[i] != target[(i + len) % 2]);
            ans = min({ ans, cnt, len - cnt });
        }
    
        return ans;
    }
};
致谢
感谢您的观看，希望对您有帮助，关注我的 力扣个人主页，欢迎热烈的交流！

下一篇：详细解析：拼接+滑动窗口+剪枝
© 著作权归作者所有
48
条评论

最热

编辑
预览







评论
精选评论(3)

kingkongk
2021-06-06
记录一下思路4的证明：

s->01串：需要i次反转；
01串->10串：需要n次反转；
s->01串->10串：对i个元素反转，再对所有n个元素反转，此时有i个元素只需保持不变即可，所以是n-i次反转
11
踩
查看 2 条回复
回复

CSlearner

2021-06-06
简化一下大佬的思路(无需使用s += s，Python)

1.对于偶数长度的字串，原题中操作一是没用的，只要统计01...和10...两种情况下反转次数取小的即可(第一次min就可以返回结果)

2.对于奇数长度的字串，i和i+len的奇偶性刚好相反，如此在滑动窗口更新cnt时，之前有加过1的需要减去1，之前没加过1的需要加上1即可(即判断s[i] == target[i % 2])

class Solution:
    def minFlips(self, s: str) -> int:
        target = '01'
        n, cnt = len(s), 0
        for i in range(n):
            if s[i] != target[i % 2]:
                cnt += 1
        min_v = min(cnt, n - cnt)

        if n % 2 == 0:
            return min_v
    
        for i in range(n):
            if s[i] == target[i % 2]:
                cnt += 1
            else:
                cnt -= 1
            min_v = min(min_v, cnt, n - cnt)
        return min_v
7
踩
查看 1 条回复
回复

小满
2021-06-06
tql。甚至都不用显式拼接 s += s ，因为减去的字符和加上的字符一样 s[i] == s[i + n]。

5
踩
查看 1 条回复
回复
评论(48)

黎志文

L3
2021-06-06
膜拜大佬，这个 target 加取余的定义太妙了！

另换一种索引方式来理解滑窗过程：

var minFlips = function(s) {
  const len = s.length;
  const target = "01";
  let cnt = 0;
  // 计算第一个滑窗
  for (let i = 0; i < len; i++) {
    cnt += s[i] !== target[i % 2];
  }

  s += s;
  let ans = Math.min(cnt, len - cnt);

  // 滑窗，从第二个开始（索引 1）
  for (let i = 1; i < len; i++) {
    // 左侧字符移出窗口，若为前一个滑窗的 cnt 贡献了次数，则在当前滑窗减去
    cnt -= s[i - 1] !== target[(i - 1) % 2];
    // 右侧字符移入窗口，若需要变换，则在当前滑窗加上
    cnt += s[i + len - 1] !== target[(i + len - 1) % 2];
    ans = Math.min(ans, cnt, len - cnt);
  }

  return ans;
};
2
踩
回复
分享
举报

作者：ikaruga
链接：https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/solution/minimum-number-of-flips-by-ikaruga-lu32/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 滑窗是为了简化计算次数的

只需要计算开头的和新加入滑窗 的



#### [1326. 灌溉花园的最少水龙头数目](https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/)

难度困难83

在 x 轴上有一个一维的花园。花园长度为 `n`，从点 `0` 开始，到点 `n` 结束。

花园里总共有 `n + 1` 个水龙头，分别位于 `[0, 1, ..., n]` 。

给你一个整数 `n` 和一个长度为 `n + 1` 的整数数组 `ranges` ，其中 `ranges[i]` （下标从 0 开始）表示：如果打开点 `i` 处的水龙头，可以灌溉的区域为 `[i - ranges[i], i + ranges[i]]` 。

请你返回可以灌溉整个花园的 **最少水龙头数目** 。如果花园始终存在无法灌溉到的地方，请你返回 **-1** 。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/19/1685_example_1.png)

```
输入：n = 5, ranges = [3,4,1,1,0,0]
输出：1
解释：
点 0 处的水龙头可以灌溉区间 [-3,3]
点 1 处的水龙头可以灌溉区间 [-3,5]
点 2 处的水龙头可以灌溉区间 [1,3]
点 3 处的水龙头可以灌溉区间 [2,4]
点 4 处的水龙头可以灌溉区间 [4,4]
点 5 处的水龙头可以灌溉区间 [5,5]
只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。
```

**示例 2：**

```
输入：n = 3, ranges = [0,0,0,0]
输出：-1
解释：即使打开所有水龙头，你也无法灌溉整个花园。
```

**示例 3：**

```
输入：n = 7, ranges = [1,2,1,0,2,1,0,1]
输出：3
```

**示例 4：**

```
输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]
输出：2
```

**示例 5：**

```
输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]
输出：1
```



# 使用优先队列优化的迪杰斯特拉算法



#### [1514. 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)

难度中等71

给你一个由 `n` 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 `edges[i] = [a, b]` 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 `succProb[i]` 。

指定两个节点分别作为起点 `start` 和终点 `end` ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。

如果不存在从 `start` 到 `end` 的路径，请 **返回 0** 。只要答案与标准答案的误差不超过 **1e-5** ，就会被视作正确答案。

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png)**

```
输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
输出：0.25000
解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25
```

**示例 2：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex2.png)**

```
输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
输出：0.30000
```

**示例 3：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex3.png)**

```
输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
输出：0.00000
解释：节点 0 和 节点 2 之间不存在路径
```

 

**提示：**

- `2 <= n <= 10^4`
- `0 <= start, end < n`
- `start != end`
- `0 <= a, b < n`
- `a != b`
- `0 <= succProb.length == edges.length <= 2*10^4`
- `0 <= succProb[i] <= 1`
- 每两个节点之间最多有一条边

通过次数7,565

提交次数23,663

请问您在哪类招聘中遇到此题？

社招

校招

实习

未遇到

贡献者

![LeetCode](https://static.leetcode-cn.com/cn-legacy-assets/images/LeetCode_avatar.png)

相关企业



相关标签



显示提示1



显示提示2



显示提示3



题目列表

随机一题

[上一题](https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/)

1514/2358

[下一题](https://leetcode-cn.com/problems/best-position-for-a-service-centre/)



C++



#### [1442. 形成两个异或相等数组的三元组数目](https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)

难度中等179

给你一个整数数组 `arr` 。

现需要从数组中取三个下标 `i`、`j` 和 `k` ，其中 `(0 <= i < j <= k < arr.length)` 。

`a` 和 `b` 定义如下：

- `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]`
- `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]`

注意：**^** 表示 **按位异或** 操作。

请返回能够令 `a == b` 成立的三元组 (`i`, `j` , `k`) 的数目。

 

**示例 1：**

```
输入：arr = [2,3,1,6,7]
输出：4
解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)
```

**示例 2：**

```
输入：arr = [1,1,1,1,1]
输出：10
```

**示例 3：**

```
输入：arr = [2,3]
输出：0
```

**示例 4：**

```
输入：arr = [1,3,5,7,9]
输出：3
```

**示例 5：**

```
输入：arr = [7,11,12,9,5,2,7,17,22]
输出：8
```

 

**提示：**

- `1 <= arr.length <= 300`
- `1 <= arr[i] <= 10^8`

#### [1515. 服务中心的最佳位置](https://leetcode-cn.com/problems/best-position-for-a-service-centre/)

难度困难37

一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 **到所有客户的欧几里得距离的总和最小** 。

给你一个数组 `positions` ，其中 `positions[i] = [xi, yi]` 表示第 `i` 个客户在二维地图上的位置，返回到所有客户的 **欧几里得距离的最小总和 。**

换句话说，请你为服务中心选址，该位置的坐标 `[xcentre, ycentre]` 需要使下面的公式取到最小值：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_edited.jpg)

与真实值误差在 `10^-5` 之内的答案将被视作正确答案。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e1.jpg)

```
输入：positions = [[0,1],[1,0],[1,2],[2,1]]
输出：4.00000
解释：如图所示，你可以选 [xcentre, ycentre] = [1, 1] 作为新中心的位置，这样一来到每个客户的距离就都是 1，所有距离之和为 4 ，这也是可以找到的最小值。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/q4_e3.jpg)

```
输入：positions = [[1,1],[3,3]]
输出：2.82843
解释：欧几里得距离可能的最小总和为 sqrt(2) + sqrt(2) = 2.82843
```

**示例 3：**

```
输入：positions = [[1,1]]
输出：0.00000
```

**示例 4：**

```
输入：positions = [[1,1],[0,0],[2,0]]
输出：2.73205
解释：乍一看，你可能会将中心定在 [1, 0] 并期待能够得到最小总和，但是如果选址在 [1, 0] 距离总和为 3
如果将位置选在 [1.0, 0.5773502711] ，距离总和将会变为 2.73205
当心精度问题！
```

**示例 5：**

```
输入：positions = [[0,1],[3,2],[4,5],[7,6],[8,9],[11,1],[2,12]]
输出：32.94036
解释：你可以用 [4.3460852395, 4.9813795505] 作为新中心的位置
```

 

**提示：**

- `1 <= positions.length <= 50`
- `positions[i].length == 2`
- `0 <= positions[i][0], positions[i][1] <= 100`

通过次数3,127

提交次数9,137

请问您在哪类招聘中遇到此题？



### 1042. 不邻接植花

 显示英文描述

 

[我的提交](https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/submissions/)[返回竞赛](https://leetcode-cn.com/contest/weekly-contest-136/)

- **通过的用户数**129
- **尝试过的用户数**220
- **用户总通过次数**130
- **用户总提交次数**519
- **题目难度****Medium**

有 `n` 个花园，按从 `1` 到 `n` 标记。另有数组 `paths` ，其中 `paths[i] = [xi, yi]` 描述了花园 `xi` 到花园 `yi` 的双向路径。在每个花园中，你打算种下四种花之一。

另外，所有花园 **最多** 有 3 条路径可以进入或离开.

你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。

以数组形式返回 **任一** 可行的方案作为答案 `answer`，其中 `answer[i]` 为在第 `(i+1)` 个花园中种植的花的种类。花的种类用  1、2、3、4 表示。保证存在答案。

 

**示例 1：**

```
输入：n = 3, paths = [[1,2],[2,3],[3,1]]
输出：[1,2,3]
解释：
花园 1 和 2 花的种类不同。
花园 2 和 3 花的种类不同。
花园 3 和 1 花的种类不同。
因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]
```

**示例 2：**

```
输入：n = 4, paths = [[1,2],[3,4]]
输出：[1,2,1,2]
```

**示例 3：**

```
输入：n = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
输出：[1,2,3,4]
```

 

**提示：**

- `1 <= n <= 104`
- `0 <= paths.length <= 2 * 104`
- `paths[i].length == 2`
- `1 <= xi, yi <= n`
- `xi != yi`
- 每个花园 **最多** 有 3 条路径可以进入或离开

# 道歉道歉

#### [1105. 填充书架](https://leetcode-cn.com/problems/filling-bookcase-shelves/)

难度中等114

附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。

你把要摆放的书 `books` 都整理好，叠成一摞：从上往下，第 `i` 本书的厚度为 `books[i][0]`，高度为 `books[i][1]`。

**按顺序** 将这些书摆放到总宽度为 `shelf_width` 的书架上。

先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 `shelf_width`），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。

需要注意的是，在上述过程的每个步骤中，**摆放书的顺序与你整理好的顺序相同**。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。

每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。

以这种方式布置书架，返回书架整体可能的最小高度。

 

**示例：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/shelves.png)

```
输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
输出：6
解释：
3 层书架的高度和为 1 + 3 + 2 = 6 。
第 2 本书不必放在第一层书架上。
```

 

**提示：**

- `1 <= books.length <= 1000`
- `1 <= books[i][0] <= shelf_width <= 1000`
- `1 <= books[i][1] <= 1000`

通过次数5,179

提交次数9,262

请问您在哪类招聘中遇到此题？

#### [1124. 表现良好的最长时间段](https://leetcode-cn.com/problems/longest-well-performing-interval/)

难度中等155

给你一份工作时间表 `hours`，上面记录着某一位员工每天的工作小时数。

我们认为当员工一天中的工作小时数大于 `8` 小时的时候，那么这一天就是「**劳累的一天**」。

所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 **大于**「不劳累的天数」。

请你返回「表现良好时间段」的最大长度。

 

**示例 1：**

```
输入：hours = [9,9,6,0,6,6,9]
输出：3
解释：最长的表现良好时间段是 [9,9,6]。
```

 

**提示：**

- `1 <= hours.length <= 10000`
- `0 <= hours[i] <= 16`

通过次数12,837

提交次数40,322

请问您在哪类招聘中遇到此题？

## 用到单调栈

#### [1375. 灯泡开关 III](https://leetcode-cn.com/problems/bulb-switcher-iii/)

难度中等44

房间中有 `n` 枚灯泡，编号从 `1` 到 `n`，自左向右排成一排。最初，所有的灯都是关着的。

在 *k* 时刻（ *k* 的取值范围是 `0` 到 `n - 1`），我们打开 `light[k]` 这个灯。

灯的颜色要想 **变成蓝色** 就必须同时满足下面两个条件：

- 灯处于打开状态。
- 排在它之前（左侧）的所有灯也都处于打开状态。

请返回能够让 **所有开着的** 灯都 **变成蓝色** 的时刻 **数目 。**

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/08/sample_2_1725.png)

```
输入：light = [2,1,3,5,4]
输出：3
解释：所有开着的灯都变蓝的时刻分别是 1，2 和 4 。
```

**示例 2：**

```
输入：light = [3,2,4,1,5]
输出：2
解释：所有开着的灯都变蓝的时刻分别是 3 和 4（index-0）。
```

**示例 3：**

```
输入：light = [4,1,2,3]
输出：1
解释：所有开着的灯都变蓝的时刻是 3（index-0）。
第 4 个灯在时刻 3 变蓝。
```

**示例 4：**

```
输入：light = [2,1,4,3,6,5]
输出：3
```

**示例 5：**

```
输入：light = [1,2,3,4,5,6]
输出：6
```

 

**提示：**

- `n == light.length`
- `1 <= n <= 5 * 10^4`
- `light` 是 `[1, 2, ..., n]` 的一个排列。

通过次数8,734

提交次数15,179

请问您在哪类招聘中遇到此题？

#### [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

难度困难538

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

```
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4 
解释：最长递增路径为 [1, 2, 6, 9]。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

```
输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
输出：4 
解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。
```

**示例 3：**

```
输入：matrix = [[1]]
输出：1
```

 

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 200`
- `0 <= matrix[i][j] <= 231 - 1`

通过次数57,907

提交次数118,750

请问您在哪类招聘中遇到此题？

### 首先要看出来这是一个图

#### [1358. 包含所有三种字符的子字符串数目](https://leetcode-cn.com/problems/number-of-substrings-containing-all-three-characters/)

难度中等61

给你一个字符串 `s` ，它只包含三种字符 a, b 和 c 。

请你返回 a，b 和 c 都 **至少** 出现过一次的子字符串数目。

 

**示例 1：**

```
输入：s = "abcabc"
输出：10
解释：包含 a，b 和 c 各至少一次的子字符串为 "abc", "abca", "abcab", "abcabc", "bca", "bcab", "bcabc", "cab", "cabc" 和 "abc" (相同字符串算多次)。
```

**示例 2：**

```
输入：s = "aaacb"
输出：3
解释：包含 a，b 和 c 各至少一次的子字符串为 "aaacb", "aacb" 和 "acb" 。
```

**示例 3：**

```
输入：s = "abc"
输出：1
```

 

**提示：**

- `3 <= s.length <= 5 x 10^4`
- `s` 只包含字符 a，b 和 c 。

通过次数6,015

提交次数12,135

请问您在哪类招聘中遇到此题？

#### [1648. 销售价值减少的颜色球](https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/)

难度中等39

你有一些球的库存 `inventory` ，里面包含着不同颜色的球。一个顾客想要 **任意颜色** 总数为 `orders` 的球。

这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 **同色球** 的数目。比方说还剩下 `6` 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 `6` 。这笔交易以后，只剩下 `5` 个黄球了，所以下一个黄球的价值为 `5` （也就是球的价值随着顾客购买同色球是递减的）

给你整数数组 `inventory` ，其中 `inventory[i]` 表示第 `i` 种颜色球一开始的数目。同时给你整数 `orders` ，表示顾客总共想买的球数目。你可以按照 **任意顺序** 卖球。

请你返回卖了 `orders` 个球以后 **最大** 总价值之和。由于答案可能会很大，请你返回答案对 `109 + 7` **取余数** 的结果。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/08/jj.gif)

```
输入：inventory = [2,5], orders = 4
输出：14
解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。
最大总和为 2 + 5 + 4 + 3 = 14 。
```

**示例 2：**

```
输入：inventory = [3,5], orders = 6
输出：19
解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。
最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。
```

**示例 3：**

```
输入：inventory = [2,8,4,10,6], orders = 20
输出：110
```

**示例 4：**

```
输入：inventory = [1000000000], orders = 1000000000
输出：21
解释：卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 109 + 7 取余为 21 。
```

 

**提示：**

- `1 <= inventory.length <= 105`
- `1 <= inventory[i] <= 109`
- `1 <= orders <= min(sum(inventory[i]), 109)`

通过次数3,558

提交次数12,831

请问您在哪类招聘中遇到此题？

#### [1315. 祖父节点值为偶数的节点和](https://leetcode-cn.com/problems/sum-of-nodes-with-even-valued-grandparent/)

难度中等67

给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：

- 该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）

如果不存在祖父节点值为偶数的节点，那么返回 `0` 。

 

**示例：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/10/1473_ex1.png)**

```
输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]
输出：18
解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。
```

 

**提示：**

- 树中节点的数目在 `1` 到 `10^4` 之间。
- 每个节点的值在 `1` 到 `100` 之间。

通过次数13,910

提交次数17,120

#### [2127. 参加会议的最多员工数](https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/)

难度困难47

一个公司准备组织一场会议，邀请名单上有 `n` 位员工。公司准备了一张 **圆形** 的桌子，可以坐下 **任意数目** 的员工。

员工编号为 `0` 到 `n - 1` 。每位员工都有一位 **喜欢** 的员工，每位员工 **当且仅当** 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 **不会** 是他自己。

给你一个下标从 **0** 开始的整数数组 `favorite` ，其中 `favorite[i]` 表示第 `i` 位员工喜欢的员工。请你返回参加会议的 **最多员工数目** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/12/14/ex1.png)

```
输入：favorite = [2,2,1,2]
输出：3
解释：
上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。
没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。
注意，公司也可以邀请员工 1，2 和 3 参加会议。
所以最多参加会议的员工数目为 3 。
```

**示例 2：**

```
输入：favorite = [1,2,0]
输出：3
解释：
每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。
座位安排同图 1 所示：
- 员工 0 坐在员工 2 和 1 之间。
- 员工 1 坐在员工 0 和 2 之间。
- 员工 2 坐在员工 1 和 0 之间。
参与会议的最多员工数目为 3 。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/12/14/ex2.png)

```
输入：favorite = [3,0,1,4,1]
输出：4
解释：
上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。
员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。
所以公司只能不邀请员工 2 。
参加会议的最多员工数目为 4 。
```

 

**提示：**

- `n == favorite.length`
- `2 <= n <= 105`
- `0 <= favorite[i] <= n - 1`
- `favorite[i] != i`

#### [LCP 20. 快速公交](https://leetcode-cn.com/problems/meChtZ/)

难度困难34

小扣打算去秋日市集，由于游客较多，小扣的移动速度受到了人流影响：

- 小扣从 `x` 号站点移动至 `x + 1` 号站点需要花费的时间为 `inc`；
- 小扣从 `x` 号站点移动至 `x - 1` 号站点需要花费的时间为 `dec`。

现有 `m` 辆公交车，编号为 `0` 到 `m-1`。小扣也可以通过搭乘编号为 `i` 的公交车，从 `x` 号站点移动至 `jump[i]*x` 号站点，耗时仅为 `cost[i]`。小扣可以搭乘任意编号的公交车且搭乘公交次数不限。

假定小扣起始站点记作 `0`，秋日市集站点记作 `target`，请返回小扣抵达秋日市集最少需要花费多少时间。由于数字较大，最终答案需要对 1000000007 (1e9 + 7) 取模。

注意：小扣可在移动过程中到达编号大于 `target` 的站点。

**示例 1：**

> 输入：`target = 31, inc = 5, dec = 3, jump = [6], cost = [10]`
>
> 输出：`33`
>
> 解释：
> 小扣步行至 1 号站点，花费时间为 5；
> 小扣从 1 号站台搭乘 0 号公交至 6 * 1 = 6 站台，花费时间为 10；
> 小扣从 6 号站台步行至 5 号站台，花费时间为 3；
> 小扣从 5 号站台搭乘 0 号公交至 6 * 5 = 30 站台，花费时间为 10；
> 小扣从 30 号站台步行至 31 号站台，花费时间为 5；
> 最终小扣花费总时间为 33。

**示例 2：**

> 输入：`target = 612, inc = 4, dec = 5, jump = [3,6,8,11,5,10,4], cost = [4,7,6,3,7,6,4]`
>
> 输出：`26`
>
> 解释：
> 小扣步行至 1 号站点，花费时间为 4；
> 小扣从 1 号站台搭乘 0 号公交至 3 * 1 = 3 站台，花费时间为 4；
> 小扣从 3 号站台搭乘 3 号公交至 11 * 3 = 33 站台，花费时间为 3；
> 小扣从 33 号站台步行至 34 站台，花费时间为 4；
> 小扣从 34 号站台搭乘 0 号公交至 3 * 34 = 102 站台，花费时间为 4；
> 小扣从 102 号站台搭乘 1 号公交至 6 * 102 = 612 站台，花费时间为 7；
> 最终小扣花费总时间为 26。

**提示：**

- `1 <= target <= 10^9`
- `1 <= jump.length, cost.length <= 10`
- `2 <= jump[i] <= 10^6`
- `1 <= inc, dec, cost[i] <= 10^6`

通过次数1,964

提交次数6,056
