# 并查集

#### [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/)

难度中等150

用以太网线缆将 `n` 台计算机连接成一个网络，计算机的编号从 `0` 到 `n-1`。线缆用 `connections` 表示，其中 `connections[i] = [a, b]` 连接了计算机 `a` 和 `b`。

网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。

给你这个计算机网络的初始布线 `connections`，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 

 

**示例 1：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_1_1677.png)**

```
输入：n = 4, connections = [[0,1],[0,2],[1,2]]
输出：1
解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。
```

**示例 2：**

**![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_2_1677.png)**

```
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]
输出：2
```

**示例 3：**

```
输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]
输出：-1
解释：线缆数量不足。
```

**示例 4：**

```
输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]
输出：0
```





## 先附上错误代码

```c++
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        vector<int> doc(n, 0);
        for (int i = 0; i < connections.size(); i++) {
            doc[connections[i][0]]++;
            doc[connections[i][1]]++;
        }
        int no_connect = 0;
        for (int i = 0; i < doc.size(); i++) {
            if (doc[i] == 0)
                no_connect++;
        }
        int rest_connect = connections.size() - (n - no_connect - 1);
        if (rest_connect < no_connect)
            return -1;
        else
            return no_connect;
    }
};
```

![](D:\document\postgraduate\note\pic\并查集.PNG)

如果图片长这样就败了，所以要使用并查集

## 什么是并查集

并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个**树**状的结构，要寻找集合的代表元素，只需要一层一层往上访问**父节点**（图中箭头所指的圆），直达树的**根节点**（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：

![img](https://pic2.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_1440w.jpg)（好像有点像个火柴人？）

用这种方法，我们可以写出最简单版本的并查集代码。

### 初始化

```c
int fa[MAXN];
inline void init(int n)
{
    for (int i = 1; i <= n; ++i)
        fa[i] = i;
}
```

假如有编号为1, 2, 3, ..., n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。

### 查询

```c
int find(int x)
{
    if(fa[x] == x)
        return x;
    else
        return find(fa[x]);
}
```

我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。

### 合并

```c
inline void merge(int i, int j)
{
    fa[find(i)] = find(j);
}
```

合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。本文末尾会给出一个更合理的比较方法。

> 王梓理解：初始有N个网络，合并一个减少一个网络，合并失败增加一条连接，并查集就是要有这样的思想，先各自为战然后逐渐merge

#### 并查集不一定要保证和图中的连线一样，但可以保证确实都能查到一个集合

正确代码

```C++
class Solution {
public:
    int makeConnected(int n, vector<vector<int>>& connections) {
        int net_num = n;
        int rest_connect = 0;
        vector<int> parent(n, 0);
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        for (int i = 0; i < connections.size(); i++) {
            int x = find(connections[i][0], parent);
            int y = find(connections[i][1], parent);
            if (x != y) {
                net_num--;
                if (parent[x] == x)
                    parent[x] = y;
            } else {
                rest_connect++;
            }
        }
        if (rest_connect < net_num - 1)
            return -1;
        else
            return net_num - 1;
    }

    int find(int x, vector<int>& parent) {
        if (x == parent[x])
            return x;
        else
            return find(parent[x], parent);
    }
};
```

