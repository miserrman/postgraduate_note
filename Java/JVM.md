# JVM

## Java内存区域与内存溢出异常

java内存区域分为以下几个区域：

![](../pic/jvm1.png)

* 方法区：方法区与java栈一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译后的代码缓存等信息。
* 虚拟机栈：为执行Java方法来服务的
* 本地方法栈：为虚拟机执行的本地方法服务
* 堆： Java堆是虚拟机管理最大的一块，Java对象里所有线程共享的一块区域，Java堆是垃圾收集器的内存区域，也被称为GC堆，Java
* 程序程序计数器：程序计数器是一块较小的内存空间，可以看作是当前线程执行字节码的行号指示器，

有的虚拟机把虚拟机栈和本地方法栈合二为一

根据《Java虚拟机栈规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemory异常。

### 运行时常量池

运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，及接口等描述信息时候，还有一项信息是**常量池表**，会在之后放在运行时常量池。

运行时常量池具有动态性，运行期间可以有新的常量放到池子中，最典型的就是String.intern()方法

```java
String.intern();
//调用intern方法的时候，字符串会全部创建在常量池上
```

当常量池无法再申请到内存的时候，会出现OutOfMemory的错误。

### Java对象的创建

当Java虚拟机遇到字节码指令new的时候，首先去检查这个指令的参数是否能在常量池被定位到一个类的符号引用，并且检查这个类是否被加载，解析，初始化过，如果没有，需要先执行类的初始化过程。

虚拟机维护一个列表，记录哪些内存块是可用的，这种分配方式称为空闲列表

> 线程安全：对象创建在虚拟机中是非常频繁的行为，仅仅修改一个指针的位置，并发状态下不是线程安全的，虚拟机是采用**CAS**重试的方式来保证操作的原子性，即每个线程先在堆中分配一小块内存，称为本地内存缓冲区，哪个线程要分配，就在本地缓冲区分配，只有本地缓冲区用完了，才需要同步锁定

### Java对象的内存布局

存储区可以化为三个部分：

* 对象头：存储对象自身的运行数据，哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳

这部分的数据被称为“Mark Word”,''Mark Word'被设计成有动态意义的数据结构.

对象头的另一部分是类型指针：指向对象的元数据

![](../pic/jvm2.png)



* 实例数据
* 对齐填充

### 对象的访问定位

对象的访问方式是由虚拟机的实现确定的，主流的访问方式是有使用句柄和直接指针两种。、

使用句柄的最大好处是对象移动了，reference不需要修改

![](../pic/jvm3.png)

使用直接指针速度更快，节省了指针定位的时间开销

![](../pic/jvm4.png)

## Java垃圾回收机制

### 可达性算法

通过一系列称为“GC Root”的根对象作为起始点集，从这些点开始，通过引用关系向下搜索，搜索过的路径称为引用链，如果某个对象没有引用链，GC Root这个对象不可达，则证明此对象不可能再被使用。

* 强引用：只要强引用关系还存在，垃圾回收器就永远不会回收的对象
* 弱引用：描述那些非必须的对象，强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。
* 虚引用：幽灵引用，为对象设置虚引用，只是回收的时候会发生一个通知
* 软引用：描述一些还有用，但非必须的对象，只被软引用关联的对象，在系统发生内存溢出前，会进行回收

​	如果对象在进行可达性分析以后，没有发现与GCRoot的引用链，那它将会被第一次标记，筛选的条件是对象是否有必要执行finalize()方法，那么该对象会被置为一个F-Queue的队列之中

随后在一条由虚拟机建立的，低调度优先级线程，去执行finalize方法，并不承诺它一定运行结束。稍后，收集器将对F-Queue队列中的对象进行第二次小规模的标记

```java
public class FinalizeEscapeGC {
	public static FinalizeEscapeGC SAVE_HOOK = null;
	public void isAlive() {
		System.out.println("yes, i am still alive :)");
	}
	@Override
	protected void finalize() throws Throwable {
		super.finalize();
		System.out.println("finalize method executed!");
		FinalizeEscapeGC.SAVE_HOOK = this;
	}
	public static void main(String[] args) throws Throwable {
		SAVE_HOOK = new FinalizeEscapeGC();
		//对象第一次成功拯救自己
		SAVE_HOOK = null;
		System.gc();
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}
		// 下面这段代码与上面的完全相同，但是这次自救却失败了
		SAVE_HOOK = null;
		System.gc();
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}
	}
}

```

对象不会调用两次finalize

### 回收方法区

方法区一般不进行垃圾回收行为。

方法区回收一般回收两种对象：

* 废弃的常量
* 不再使用的类型

### 垃圾收集算法

当前的垃圾收集算法，都遵从了分代收集的理论。分代收集建立在两个分代假说上：

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过多次垃圾收集的对象就越难以消亡

收集器应该将Java堆划分成不同的区域，然后回收对象依据其年龄分配到不同的区域存储。

出现一个部分收集的问题？

> 新生代垃圾收集：收集发现老年代引用了新生代的对象，因此要重新扫描一遍老年代。

出现了一个假说：这种现象是极少的，不用为了这种现象去扫描整个老年代

部分收集：

* 新生代收集
* 老年代收集
* 混合收集
* 整堆收集

### 标记清除算法

最早的是，标记和清除两个阶段

标记清除算法的缺点：

1. 执行效率不稳定
2. 空间碎片太多

### 标记复制算法

它将可用的内存分成大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将存货的对象复制到另外一块去，然后把已经使用过的内存空间一次清理掉，这种方法会产生大量的复制花费。

### 标记整理算法

针对老年代对象存储的特征，后续步骤不是直接对可回收对象进行清理，而是让所有对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。

如果移动存活对象，并更新引用必须停机才能进行，也被称为Stop the world

> 比较活泛的一个想法：先进性标记清除算法，等到内存乱到一定程度，再运行标记整理算法。

### HotSpot算法实现机制

### 根节点枚举

可达性分析算法：GCRoots集合找引用链，根节点枚举必须暂停用户线程，根节点枚举会造成stop the word的困境，现在已经可以开始并发

目前主流java虚拟机使用：准确式垃圾收集，当用户线程停顿下来后，不需要一个不漏的检查完所有执行上下文和全局引用位置，虚拟机可以得到哪些地方存放着对象引用。

使用OopMap达到这个目的。

在OopMap的帮助下，HotSpot可以快速完成GC Root枚举，引用关系的变化，可能会导致OopMap的变化。

**设立安全点：只在特定的位置，记录这些信息。**

对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括 执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。

而主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他 需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新 对象。

### 安全区域

解决阻塞的程序：需要设置安全区域

安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。

当用户线程执行到安全区域的代码后，会标识自己已经进入了安全区域，所以虚拟机不需要管进入安全区域的线程。

### 记忆集与卡表

记忆集：在分代收集的场景中，解决对象跨代引用的问题。垃圾收集器在新生代建立了名为记忆集的数据结构，避免把整个老年代加入了扫描范围。

记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。这种记录不需要太多的空间。

* 字长精度
* 对象精度
* 卡精度：将记录精确到一块内存

### 并发的可达性分析

* 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是 白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。 

* 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对 象不可能直接（不经过灰色对象）指向某个白色对象。 
* 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

并发扫描容易造成的问题，所以必须在一个一致性快照上进行可达性分析。

![](../pic/jvm5.png)

