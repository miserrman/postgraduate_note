![image-20220207181217080](C:\Users\26583\AppData\Roaming\Typora\typora-user-images\image-20220207181217080.png)



# Unix系统的高层特征

* 文件系统：层次结构，对文件数据的一致处理，建立与删除文件的能力，文件的动态增长，文件的动态保护
* 处理环境：一个程序是一个可执行环境，一个进程是执行中程序的实例，在unix系统中可以执行多个进程
* 构件原语：提供操作系统原语（进行系统调用），使用户能够书写小的，模块化的程序，并把他们作为构件去构筑更复杂的程序，重定向I/O的能力便是shell用户一个可见的原语

### 操作系统内核：

内核代表用户进程完成各种原语操作，以便支持上述描述过的用户接口

### 中断与例外

UNIX操作系统允许I/O外围设备异步的中断CPU,接收到中断时，内核保存当前的上下文，判定中断原因，为中断服务



## Unix操作系统内核

图中有三个层次，用户，内核和硬件，系统调用和库接口体现了用户程序与内核间的边界，系统调用像C语言中普通的函数调用，库把这些函数映射成操作系统需要的原语

系统调用的集合可以分为**文件子系统的交互部分和进程子系统的交互部分**

文件子系统通过缓冲机制读取文件数据，缓冲机制调节内核在二级设备之间的数据流

![](D:\document\postgraduate\note\pic\os1.png)

### 内核数据结构

#### 文件子系统概貌

一个文件的内部表示由一个索引节点给出，索引节点描述了文件数据在磁盘上的布局，文件的所有者，存取的许可权。

index node

```c
struct iNode {
    void* adress;
    char* name;
    char* property
}INode;
```

当系统调用open("/fs", 1)内核检查“/fs2”所对应的索引节点，当一个进程建立一个新文件时，内核分配一个尚未使用的索引节点，索引节点存在文件系统中，当操纵文件时，内核将它们读到**内存索引节点表**中。

内核还包括文件表和用户文件描述符表，文件表是一个全局核心结构，用户文件描述表对每个进程分配一个，当一个进程打开或建立一个文件时，内核为每个表中相应于该文件的索引节点分配一个表项

> 文件表只在全局打开的时候使用，而索引节点存储了文件的所有信息，文件表保存着文件中字节的偏移量，下一次读写将从那里开始，用户文件描述符保存着一个进程打开的所有文件。

![](../pic/os2.png)



一个文件系统由一个逻辑块序列组成，每个块都包含512个字节，1024个字节或者2048个字节，依赖于系统实现

引导块：占据文件系统的开头，是一个扇区，含有被读人机器的引导代码。

超级块：描述了文件系统的状态，它有多大，它能存储多少文件，文件系统在何处可以找到空闲空间

索引节点表

数据块

### 进程

unix系统上的进程是被系统调用fork创建的实体，除了0进程以外，所有进程都是fork创建的，调用系统调用fork进程的父进程，新创建的是子进程，每一个进程都有一个进程ID来标识进程

> 0进程是一个特殊进程，它是在系统引导时被手动创建的，当它创建了一个进程1进程后，就与0进程变成对换进程，1进程是系统中每个进程的祖先。

　exec把当前进程映像替换成新的程序文件，而且该新程序通常从main函数开始执行，进程ID并不改变。我们称调用exec的进程为调用进程（calling process），称新执行的程序为新程序（new program）

系统调用exec期间，内核把可执行文件装入栈区中，被装入的进程被称为正文区，数据区和栈区组成，栈区是自动创建的，大小是运行的时候内核自动调节的。

unix系统核心栈和用户栈是分开的

![](../pic/os3.png)

**核心态运行的进程往往是不可抢占的**

## 数据缓冲区高速缓冲区

对文件系统的一切操作，内核都能通过每次从磁盘上直接读，直接写来实现，慢的磁盘传输速率会让响应时间变长，内核通过保持一个高速缓冲来减小磁盘的存储速率。高速缓冲含有最近使用过的磁盘的数据

**描述内核用于操纵高速缓冲中的缓冲区的算法**

缓冲区由两个部分组成：

* 存储器数组
* 标识缓冲区的缓冲头部

一个缓冲区的数据与文件系统上的逻辑磁盘的数据相对应，并且内核通过考察缓冲区头部的内容来识别缓冲区的内容，缓冲区是磁盘主存的拷贝

![](../pic/os4.png)

缓冲头部包含一个设备号和块号的字段，两个字段指明了文件系统与磁盘数据的块号，并且唯一标识了该缓冲区

> 缓冲区状态是如下状态的组合，缓冲区当前为上锁，缓冲区包含有效数据，内核把缓冲区重新分配出去必须把缓冲区写在磁盘上，这种被称为延迟写，内核当前正在把

内核按照最少使用算法将数据存储在缓冲池中，在它把缓冲区分配给一个磁盘后，内核维护一个缓冲区的空闲表

当内存存取一个磁盘块时，它使用适当的设备号和块号去找相应的缓冲区，它并不是搜索整个缓冲区池，它把缓冲区组织成一个一个队列，在队列上使用散列函数。

![](../pic/os5.png)

```
系统中空闲表和散列队列的配合是这样的：所有的缓冲区都可以在散列队列里面，可以通过散列函数被找到，空闲块可以存在于散列队列和空闲表中，如果系统想查找相应的空闲表，则查找散列队列，如果摘下空闲块，则会搜索空闲队列。
```

**注意：一个块如果不被使用就是空闲块，而不是里面没数据才被称为空闲块**

#### 获取缓冲池上一个块的写法

1. 在散列队列上可以找到该块，并且该缓冲区空闲

2. 在散列队列上找不到该块，系统分配一个空闲块
3. 在散列队列上找不到该块，系统没有空闲块
4. 内核在散列队列

#### 分配了缓冲区释放缓冲区的写法

![](../pic/os7.png)

上面缓冲区送入头部是发生了I/O错误，可以覆盖缓冲区

**这是一个缓冲区的图**

![](../pic/os8.png)

高速缓冲全都是优点，只有延迟写这个致命的缺点。